

<!DOCTYPE html>
<html>

<head>
<meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<title>xperiments.io</title>

<link rel="icon" type="image/x-icon" href="/favicon.ico">
<link rel="stylesheet" type="text/css" href="/styles/style.css">
<link rel="stylesheet" type="text/css" href="/styles/prism.css">
<link rel="stylesheet" type="text/css" href="/styles/nav.css">
<link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Oxygen:400,700">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, minimal-ui">

</head>

<body class="home-template tag-text tag-formatting blog-has-cover">
<a name="top"></a>
<svg display="none" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="80" height="32" viewBox="0 0 80 32">
    <defs>
        <g id="icon-github">
            <path class="path1" d="M21.088 18.096c-1.149 0-2.080 1.29-2.080 2.878 0 1.59 0.931 2.88 2.080 2.88s2.080-1.29 2.080-2.88c-0.002-1.59-0.933-2.878-2.080-2.878zM28.33 10.602c0.237-0.584 0.248-3.904-1.014-7.082 0 0-2.899 0.317-7.283 3.326-0.92-0.254-2.477-0.381-4.032-0.381-1.557 0-3.112 0.128-4.034 0.381-4.382-3.010-7.28-3.326-7.28-3.326-1.262 3.178-1.253 6.498-1.014 7.082-1.485 1.613-2.392 3.549-2.392 6.194 0 11.498 9.539 11.682 11.947 11.682 0.546 0 1.63 0.002 2.774 0.003 1.144-0.002 2.229-0.003 2.771-0.003 2.41 0 11.947-0.184 11.947-11.682 0-2.645-0.906-4.581-2.39-6.194zM16.045 27.064h-0.088c-6.035 0-10.736-0.72-10.736-6.586 0-1.405 0.498-2.709 1.674-3.79 1.966-1.803 5.29-0.848 9.062-0.848 0.014 0 0.030 0 0.045-0.002 0.016 0 0.030 0.002 0.043 0.002 3.773 0 7.098-0.955 9.062 0.848 1.176 1.082 1.672 2.386 1.672 3.79 0 5.866-4.698 6.586-10.734 6.586zM10.914 18.096c-1.149 0-2.080 1.29-2.080 2.878 0 1.59 0.931 2.88 2.080 2.88s2.080-1.29 2.080-2.88c0-1.59-0.931-2.878-2.080-2.878z" />
        </g>
        <g id="icon-twitter">
            <path class="path1" d="M30.72 6.869c-1.085 0.482-2.248 0.805-3.47 0.952 1.248-0.747 2.206-1.931 2.656-3.341-1.166 0.691-2.459 1.195-3.834 1.466-1.102-1.174-2.672-1.907-4.41-1.907-3.336 0-6.040 2.704-6.040 6.038 0 0.474 0.053 0.934 0.157 1.376-5.019-0.251-9.47-2.656-12.448-6.31-0.522 0.891-0.821 1.93-0.821 3.037 0 2.096 1.067 3.944 2.688 5.027-0.99-0.032-1.922-0.302-2.736-0.755 0 0.026 0 0.050 0 0.075 0 2.926 2.083 5.366 4.845 5.923-0.506 0.138-1.040 0.211-1.592 0.211-0.389 0-0.766-0.037-1.136-0.107 0.768 2.4 3 4.146 5.642 4.194-2.067 1.621-4.67 2.586-7.501 2.586-0.488 0-0.968-0.029-1.44-0.085 2.672 1.714 5.846 2.714 9.259 2.714 11.109 0 17.184-9.203 17.184-17.186 0-0.261-0.005-0.522-0.018-0.781 1.181-0.851 2.203-1.915 3.014-3.126z" />
        </g>
        <g id="xperiments.io">
            <path d="M27.961,82.996l19.83-16.636c0.639-0.506,0.959-1.292,0.959-2.362c0-1.067-0.319-1.854-0.957-2.359L27.962,45.001
            c-2.101-1.759-3.152-3.946-3.152-6.559c0-2.33,0.839-4.331,2.513-6.006c1.677-1.675,3.678-2.514,6.007-2.514
            c1.989,0,3.949,0.795,5.879,2.382l60.828,50.692c2.101,1.761,3.151,3.949,3.151,6.561c0,2.33-0.836,4.332-2.513,6.008
            c-1.674,1.675-3.677,2.513-6.005,2.513c-1.987,0-3.947-0.794-5.878-2.386L67.65,78.072c-1.246-1.032-2.404-1.548-3.48-1.548
            c-1.3,0-2.572,0.518-3.818,1.551L39.208,95.695c-1.93,1.589-3.889,2.383-5.878,2.383c-2.329,0-4.33-0.838-6.006-2.513
            c-1.674-1.676-2.513-3.678-2.513-6.008C24.811,86.944,25.861,84.757,27.961,82.996z M78.24,41.098l10.55-8.794
            c1.932-1.587,3.892-2.382,5.879-2.382c2.33,0,4.333,0.839,6.007,2.514c1.677,1.676,2.513,3.677,2.513,6.006
            c0,2.614-1.05,4.8-3.151,6.561l-9.818,8.068c-1.985,1.664-3.971,2.494-5.956,2.494c-1.475,0-2.579-0.141-3.318-0.424
            c-0.737-0.283-1.646-0.965-2.724-2.043c-1.643-1.646-2.466-3.632-2.466-5.959C75.757,44.473,76.585,42.458,78.24,41.098z" stroke="rgba(0,0,0,.3)" stroke-width="4"/>
        </g>
		<g id="tag">
			<path d="M31.391 13.883l-5-8c-0.73-1.169-2.012-1.88-3.391-1.88h-19c-2.209 0-4 1.791-4 4v16c0 2.209 1.791 4 4 4h19c1.379 0 2.66-0.711 3.391-1.881l5-8c0.812-1.295 0.812-2.942 0-4.239zM29.695 17.062l-5 8.002c-0.367 0.588-1.002 0.939-1.695 0.939h-19c-1.103 0-2-0.898-2-2v-16c0-1.103 0.897-2 2-2h19c0.693 0 1.328 0.352 1.695 0.939l5 8c0.403 0.645 0.403 1.477 0 2.12zM23 13.003c-1.658 0-3 1.343-3 3s1.342 3 3 3c1.656 0 3-1.344 3-3 0-1.657-1.344-3-3-3zM23 18.004c-1.105 0-2-0.896-2-2s0.895-2 2-2c1.104 0 2 0.896 2 2s-0.896 2-2 2z"></path>
		</g>
    </defs>
</svg>
<nav id="bt-menu" class="bt-menu">
    <a class="bt-menu-trigger"><svg style="width:40px; height:40px; fill:FFF; " viewBox="0 0 128 128"><circle cx="64" fill-opacity=".1" stroke-width="1" cy="64.001" r="64"/><use xlink:href="#xperiments.io"></use></a>
    <ul>
        <li><a href="/pages/about">About</a></li>
        <li><a href="/">Blog</a></li>
        <li><a href="/archives.html">Archives</a></li>
        <li><a href="/pages/projects">Projects</a></li>
    </ul>
    <ul>
        <li><a href="//github.com/xperiments" target="_blank" class="bt-icon"><svg style="width:32px; height:32px;" viewBox="0 0 32 32"><use xlink:href="#icon-github"></use></svg></a></li>
        <li><a href="//twitter.com/@xperiments" target="_blank" class="bt-icon"><svg style="width:32px; height:32px;" viewBox="0 0 32 32"><use xlink:href="#icon-twitter"></use></svg></a></li>
    </ul>

</nav>









<div class="blog-cover" style="position:relative; background-image: url(/images/large__14352126201.jpg);background-size: cover;background-position: center;">
    <div class="xp-cover-gradient"></div>
    <header class="xp-post-info">
        <span href="/posts/serailizing-typescript-objects/">@xperiments <time datetime="Thu Jul 10 2014 00:00:00 GMT+0200 (CEST)"> July 10, 2014</time>.</span><br/>
    </header>
    <header class="xp-cover xp-antialiased">
        <h1 class="post-title">Serailizing Typescript Objects</h1>
        
		<h4><svg style="width:22px; height:22px; fill:#FFF; margin-bottom:-6px;" viewBox="0 0 32 32"><use xlink:href="#tag"></use></svg> Typescript,Serialization</h4> 
		<div class="xp-cover-arrow">v</div>
    </header>
</div>

<!-- header class="site-header">
    <a class="blog-logo" href="/"><img src="/images/logo.svg" alt="Blog Logo" /></a>
</header -->
<main class="site-content" role="main">

    <article class="post tag-text tag-formatting">


        <section class="post-content">

                    <h1 id="typescript-serializer">typescript-serializer</h1>
<p>Lately I&#39;ve been thinking it would be interesting to have a data serialization system to be used in some client-side developments in which I am working.</p>
<p>But first, for those that don&#39;t know what is data serialization: ( wikipedia )</p>
<blockquote>
<p>In computer science, in the context of data storage, <strong>serialization</strong> is the process of translating data structures or object state into a format that can be stored (for example, in a file or memory buffer, or transmitted across a network connection link) and reconstructed later in the same or another computer environment.[1] When the resulting series of bits is reread according to the serialization format, it can be used to create a semantically identical clone of the original object</p>
</blockquote>
<p>I have used these systems before in Java and Actionscript, an missed not being able to have a similar system in Typescript so I have developed a fairly simple one named typescript-serializer.</p>
<p>I took concepts from Java and Actionscript, adapting them to the requirements and limitations of Typescript.</p>
<p>You can find it at <a href="https://github.com/xperiments/typescript-serializer">GitHub</a>.</p>
<h2 id="serializable-classes">Serializable Classes</h2>
<p>Imagine a User Class like this:</p>
<pre><code class="language-javascript">class User
{
    name:string;
    surname:string;
    street:string;
    number:number;
}</code></pre><h3 id="make-it-serializable-by-extending-serializable">Make it &quot;Serializable&quot; by extending Serializable</h3>
<p>This methods are inherited when extending from Serializable:</p>
<ul>
<li>writeObject();</li>
<li>readObject(obj:ISerializableObject);</li>
<li>stringify();</li>
<li>parse(jsonstring);</li>
</ul>
<h3 id="defining-serializable-properties">Defining Serializable properties</h3>
<p>We will make the definition of what properties and how these properties should be serialized by creating a &quot;serializer&quot; class that must implement ISerializerHelper. </p>
<pre><code class="language-javascript">class UserSerializer implements ISerializerHelper
{
    /* REMEMBER we need to init to null all props to this work */
    "@serializer":string = null; 
    name:string = null;
    surname:string = null;
    street:string = null;
    number:number = null; 
}</code></pre><p>As we see in this example, we have defined the properties we want to serialize from the &quot;User&quot; class by declaring it in the new class an initializing it to <strong>NULL ( this is IMPORTANT )</strong> .</p>
<h3 id="registering-serializable-classes">Registering Serializable Classes</h3>
<p>So far the only thing we have done is to define which classes are serializable and how they should be serialized, but for this to work we need to register them together using the method <strong>registerClass</strong> of the class Serializer.</p>
<pre><code class="language-javascript">Serializer.registerClass( classContext:()=>any, SerializerDataClass:typeof SerializerDefinition ):void</code></pre><p>It takes 2 arguments:</p>
<ul>
<li><strong>classContext</strong> // a function that returns the Main class to Serialize</li>
<li><strong>SerializerDataClass:any</strong> // The SerializableData Class that defines how &amp; what elements to serialize.</li>
</ul>
<pre><code class="language-javascript">// register here the User and UserSerializer
Serializer.registerClass( ()=>User, UserSerializer );</code></pre><p>We must be careful in how we define &quot;class Context.&quot; It must be a function that just returns the serialized class and nothing else. This function is used later to determine his name.</p>
<h2 id="usage">Usage</h2>
<p>Now that we have everything in place, we will create a new &quot;User&quot; and see how serialize and deserialize it:</p>
<pre><code class="language-javascript">// create a new User (source) instance:
var sourceInstance:User = new User();
    sourceInstance.name = "John";
    sourceInstance.surname = "Smith";
    sourceInstance.street = "Some Street Address";
    sourceInstance.number = 67;</code></pre><h3 id="serializing">Serializing</h3>
<p>The writeObject method inherited from Serializable lets us serialize the object to another &quot;transportable&quot; object.</p>
<pre><code class="language-javascript">var serializedObject:any = sourceInstance.writeObject();</code></pre><p>Tracing out the object in the console, will be something similar to this:</p>
<pre><code class="language-javascript">{
    "@serializable": "User",
    "name": "John",
    "surname": "Smith",
    "street": "Some Street Address",
    "number": 67
}</code></pre><p>We may also use the stringify () method that will return a much more transportable JSON representation.</p>
<pre><code class="language-javascript">var serializedJSONRepresentationt:string = sourceInstance.stringify();</code></pre><h3 id="deserializing">Deserializing</h3>
<p>To reconstruct the serialized object/s, we can use the inherited methods &quot;readObject&quot; or &quot;parse&quot; of our User class.</p>
<pre><code class="language-javascript">// create a new User (source) instance:
var sourceInstance:User = new User();
    sourceInstance.name = "John";
    sourceInstance.surname = "Smith";
    sourceInstance.street = "Some Street Address";
    sourceInstance.number = 67;

// Serialize the instance
var serializedObject:any = sourceInstance.writeObject();

// create a new instance of User
var serializedObjectClone:any = new User();

// reconstruct it from the serializedObject we have created 
serializedObjectClone.readObject( serializedObject );</code></pre><p>We may also use the parse( json:string ) method that will reconstruct the object from a JSON string.</p>
<h2 id="custom-serialization-of-properties">Custom serialization of properties</h2>
<p>In addition to specifying which properties are to be serialized, we can also specify how they should be serialized. </p>
<p>For example we will use our class User adding a &quot;Date&quot; property. Later want it to be serialized as YYYY / MM / DD.</p>
<pre><code class="language-javascript">class User
{
    ...
    date:Date;
    ...
}</code></pre><p>To define how to process this property &quot;date&quot;, we will create two new methods in our UserSerializer class. </p>
<p>These methods must be named with the following format:</p>
<pre><code class="language-javascript">set_propertyName( property:PropertyType ):string
get_propertyName( property:string ):Type</code></pre><p>Applying it to our class &quot;User&quot; would be:</p>
<pre><code class="language-javascript">
class User extends Serializable
{
    name:string;
    surname:string;
    street:string;
    number:number;
    date:Date;
}

class UserSerializer implements ISerializerHelper
{
    "@serializer":string = null;
    date:Date = null;
    set_date(date:Date):string
    {
        return [ date.getFullYear(), date.getMonth()+1, date.getDate()].join('/');
    }
    get_date(dateString:string):Date
    {
        var dateParts:string[] = dateString.split('/');
        var date = new Date();
        date.setFullYear( parseInt(dateParts[0],10));
        date.setMonth( parseInt(dateParts[1],10)-1);
        date.setDate( parseInt(dateParts[2],10));
        return date;
    }
}</code></pre><h2 id="demo">Demo</h2>
<p>Here is the full code example. You can play with it at the Typescript Playground by clicking on the TSPlay button at bottom.</p>
<pre><code class="language-typescript">module io.xperiments.utils.serialize
{
    /**
     * The interface any ClassSerializer class must implement
     */
    export interface ISerializerHelper
    {
        "@serializer":string;
    }

    /**
     * The interface any Serializable class must implement
     */
    export interface ISerializable
    {
        writeObject():any;
        readObject( obj:ISerializable ):void;
        stringify():string;
        parse( string:string ):void;
    }

    /**
     *    Holds information about the class serializer & keys of a Type
     */
    export interface ISerializableRegister
    {
        keys:string[];
        serializerData:typeof SerializerHelper;
    }

    /**
     *    Holds a dictionary of ISerializableRegister
     */
    export interface ISerializableRegisters
    {
        [key:string]:ISerializableRegister;
    }

    /**
     * The interface any ClassSerializer extends
     */
    export class SerializerHelper implements ISerializerHelper
    {
        "@serializer":string;
    }

    /**
     *    The base class all serializable classes must extend
     */
    export class Serializable implements ISerializable
    {
        /**
         * Serializes the current instance & returns a transportable object
         * @returns {ISerializable}
         */
        public writeObject():ISerializable
        {

            return Serializer.writeObject( this );
        }

        /**
         * Rehidrates the current instance with the values provided by the passed object
         * @param obj
         */
        public readObject(obj:ISerializable):ISerializable
        {
            return Serializer.readObject(this, obj);
        }

        /**
         * Serializes the current instance & returns a JSON string representation
         * @param pretty
         * @returns {string}
         */
        public stringify( pretty:boolean = false ):string
        {
            return JSON.stringify( Serializer.writeObject( this ), null, pretty? 4:0 );
        }

        /**
         * Rehidrates the current instance with the values provided by the passed JSON string
         * @param string
         */
        public parse( string:string ):void
        {
            Serializer.readObject(this, JSON.parse( string ));
        }

    }

    /**
     *
     */
    export class Serializer
    {
        private static serializableRegisters:ISerializableRegisters = {};

        /**
         * Registers a class in the serializable class register
         * @param classContext
         * @param SerializerDataClass {typeof SerializerDefinition}
         */
        public static registerClass( classContext:()=>any, SerializerDataClass:typeof SerializerHelper ):void
        {

            // determine class global path by parsing the body of the classContext Function
            var classPath:string = /return ([A-Za-z0-9_$.]*)/g.exec(classContext.toString())[1];

            // Check if class has been processed
            if( Serializer.serializableRegisters[ classPath ] )
            {
                throw new Error('Class '+classPath+' already registered');
            }

            Serializer.getClassFromPath( classPath ).prototype['@serializable'] = classPath;

            Serializer.serializableRegisters[classPath] =
            {
                keys:Serializer.getMixedNames( SerializerDataClass ),
                serializerData:SerializerDataClass
            };
        }

        /**
         * Serializes the passed instance & returns a transportable object
         * @param instance
         * @returns {any}
         */
        public static writeObject( instance:ISerializable ):ISerializable
        {
            var obj:any = <ISerializable>{};
            var register:ISerializableRegister = Serializer.getSerializableRegister( instance );
            register.keys.forEach(( key:string )=>
            {
                var value:any = instance[key];
                if( !value && !Serializer.isNumeric( value )) return; // don't getSerializableProperties void/empty/undefined
                Serializer.writeAny( obj, key, value, register.serializerData );
            });
            return obj;
        }

        /**
         * Rehidrates the instance with the values provided by the passed object
         * @param instance
         * @param obj
         */
        public static readObject( instance:ISerializable, obj:ISerializable ):ISerializable
        {
            var register:ISerializableRegister = Serializer.getSerializableRegister( instance );
            Serializer.getSerializableRegister( instance ).keys
                .forEach( ( key:string )=> Serializer.readAny( obj[key], key, instance, register.serializerData ) );
            return instance;
        }



        // Private Methods
        /**
         *
         * @param array
         * @returns {any[]}
         */
        private static writeArray( array:any[] ):any[]
        {
            var dummyObjectArray:{array:any[]} = { array:[] };
            array.forEach( ( value , i )=> Serializer.writeAny( dummyObjectArray.array, i, value , Serializer.getSerializableRegisterData( value )  ) );
            return dummyObjectArray.array;
        }

        /**
         *
         * @param value
         * @param key
         * @param obj
         * @param SerializerDataClass
         */
        private static writeAny( obj:any,key:any,value:any, SerializerDataClass:any = null , fromArray:boolean = false )
        {

            if( SerializerDataClass && typeof SerializerDataClass.prototype["set_"+key] == "function" )
            {
                obj[key] = SerializerDataClass.prototype["set_"+key]( value );
                return;
            }

            var elementType = typeof value;

            switch( true )
            {
                case elementType=="boolean":
                case elementType=="string":
                case elementType=="number":
                    obj[key] = value;
                    break;
                case Array.isArray( value ):
                    obj[key] = Serializer.writeArray( value );
                    break;
                case elementType=="object" && !Array.isArray( value ):
                    obj[key] = Serializer.isExternalizable( value ) ? Serializer.writeObject( value ):JSON.parse(JSON.stringify( value ));
                    break;
            }

        }

        /**
         * @param array
         * @returns {any[]}
         */
        private static readArray( array:any[] ):any[]
        {
            var resultArray:any[] = [];

            array.forEach( ( element, i )=>{
                Serializer.readAny( element, i, resultArray, Serializer.getSerializableRegisterData( element ) );
            });
            return resultArray;
        }

        /**
         ** @param element
         * @param key
         * @param target
         * @param SerializerDataClass
         */
        private static readAny( element:any, key:any, target:any, SerializerDataClass:any )
        {

            if( SerializerDataClass && typeof SerializerDataClass.prototype["get_"+key] == "function" )
            {
                target[key] = SerializerDataClass.prototype["get_"+key]( element );
                return;
            }

            var type:string = typeof element;
            switch( true )
            {
                case type=="boolean":
                case type=="string":
                case type=="number":
                    target[key] = element;
                    break;
                case Array.isArray( element ):
                    target[key] = Serializer.readArray( element );
                    break;
                case type=="object" && !Array.isArray( element ):
                    if( element.hasOwnProperty('@serializable') )
                    {
                        var moduleParts:string[] = element['@serializable'].split('.');
                        var classPath:string = moduleParts.join('.');
                        if( !target[key] ) target[key] = Serializer.getClass(classPath);
                        target[key].readObject( element );
                     }
                    else
                    {
                        target[key] = element;
                    }
                    break;
            }

        }

        /* Helper Methods */

        /**

         ** @param SerializerDataClass
         * @returns {string[]}
         */
        private static getMixedNames( SerializerDataClass:any ):string[]
        {
            return Object.getOwnPropertyNames( new SerializerDataClass() ).concat("@serializable");
        }


        /**

         ** @param instance
         * @returns {boolean}
         */
        private static isExternalizable( instance ):boolean
        {
            return '@serializable' in instance && typeof instance.writeObject == "function" && typeof instance.readObject == "function";
        }

        /**

         ** @param name
         * @param context
         * @returns {any}
         */
        private static getClassFromPath( name:string , context:any = window ):any
        {
            name.split('.').forEach( ctx=>context = context[ ctx ] );
            return context;
        }

        /**

         ** @param name
         * @param context
         * @returns {any}
         */
        private static getClass( name:string , context:any = window ):any
        {
            name.split('.').forEach( ctx=>context = context[ ctx ] );
            return new context;
        }

        /**

                  ** @param instance
         * @returns {ISerializableRegister}
         */
        private static getSerializableRegister( instance:ISerializable ):ISerializableRegister
        {
            var props:ISerializableRegister = Serializer.serializableRegisters[ instance['@serializable'] ] || null;
            return props;
        }

        /**
         *
         * @param instance
         * @returns {ISerializableRegister}
         */
        private static getSerializableRegisterData( instance:ISerializable ):typeof SerializerHelper
        {

            var register = Serializer.getSerializableRegister( instance );
            return register ? register.serializerData:null;
        }

        private static isNumeric(n:any):boolean
        {
            return !isNaN(parseFloat(n)) && isFinite(n);
        }
    }
}

/* DEMO CODE */


import ISerializable = io.xperiments.utils.serialize.ISerializable;
import Serializable = io.xperiments.utils.serialize.Serializable;

import ISerializerHelper = io.xperiments.utils.serialize.ISerializerHelper;
import Serializer = io.xperiments.utils.serialize.Serializer;

class User extends Serializable
{
    name:string;
    surname:string;
    street:string;
    number:number;
    date:Date;
}

class UserSerializer implements ISerializerHelper
{
    "@serializer":string = null;
    date:Date = null;
    name:string  = null;
    surname:string  = null;
    street:string  = null;
    number:number  = null;
    set_date(date:Date):string
    {
        return [ date.getFullYear(), date.getMonth()+1, date.getDate()].join('/');
    }
    get_date(dateString:string):Date
    {
        var dateParts:string[] = dateString.split('/');
        var date = new Date();
        date.setFullYear( parseInt(dateParts[0],10));
        date.setMonth( parseInt(dateParts[1],10)-1);
        date.setDate( parseInt(dateParts[2],10));
        return date;
    }
}

// Registration
Serializer.registerClass(()=>{ return User },UserSerializer);


// Creane new user instance and populate it with some values
var sourceInstance:User = new User();
    sourceInstance.name = "John";
    sourceInstance.surname = "Smith";
    sourceInstance.street = "Some Street Address";
    sourceInstance.number = 67;
    sourceInstance.date = new Date();

// Serialize it and store it somewhere    
var serializedObject:ISerializable = sourceInstance.writeObject();

// later to recompose it from data saved to disk
var cloneUserInstance:User = new User();
cloneUserInstance.readObject( serializedObject );

console.log( sourceInstance, cloneUserInstance )</code></pre><div xp-code-play="typescript"><pre>module io.xperiments.utils.serialize
{
    /**
     * The interface any ClassSerializer class must implement
     */
    export interface ISerializerHelper
    {
        "@serializer":string;
    }

    /**
     * The interface any Serializable class must implement
     */
    export interface ISerializable
    {
        writeObject():any;
        readObject( obj:ISerializable ):void;
        stringify():string;
        parse( string:string ):void;
    }

    /**
     *    Holds information about the class serializer & keys of a Type
     */
    export interface ISerializableRegister
    {
        keys:string[];
        serializerData:typeof SerializerHelper;
    }

    /**
     *    Holds a dictionary of ISerializableRegister
     */
    export interface ISerializableRegisters
    {
        [key:string]:ISerializableRegister;
    }

    /**
     * The interface any ClassSerializer extends
     */
    export class SerializerHelper implements ISerializerHelper
    {
        "@serializer":string;
    }

    /**
     *    The base class all serializable classes must extend
     */
    export class Serializable implements ISerializable
    {
        /**
         * Serializes the current instance & returns a transportable object
         * @returns {ISerializable}
         */
        public writeObject():ISerializable
        {

            return Serializer.writeObject( this );
        }

        /**
         * Rehidrates the current instance with the values provided by the passed object
         * @param obj
         */
        public readObject(obj:ISerializable):ISerializable
        {
            return Serializer.readObject(this, obj);
        }

        /**
         * Serializes the current instance & returns a JSON string representation
         * @param pretty
         * @returns {string}
         */
        public stringify( pretty:boolean = false ):string
        {
            return JSON.stringify( Serializer.writeObject( this ), null, pretty? 4:0 );
        }

        /**
         * Rehidrates the current instance with the values provided by the passed JSON string
         * @param string
         */
        public parse( string:string ):void
        {
            Serializer.readObject(this, JSON.parse( string ));
        }

    }

    /**
     *
     */
    export class Serializer
    {
        private static serializableRegisters:ISerializableRegisters = {};

        /**
         * Registers a class in the serializable class register
         * @param classContext
         * @param SerializerDataClass {typeof SerializerDefinition}
         */
        public static registerClass( classContext:()=>any, SerializerDataClass:typeof SerializerHelper ):void
        {

            // determine class global path by parsing the body of the classContext Function
            var classPath:string = /return ([A-Za-z0-9_$.]*)/g.exec(classContext.toString())[1];

            // Check if class has been processed
            if( Serializer.serializableRegisters[ classPath ] )
            {
                throw new Error('Class '+classPath+' already registered');
            }

            Serializer.getClassFromPath( classPath ).prototype['@serializable'] = classPath;

            Serializer.serializableRegisters[classPath] =
            {
                keys:Serializer.getMixedNames( SerializerDataClass ),
                serializerData:SerializerDataClass
            };
        }

        /**
         * Serializes the passed instance & returns a transportable object
         * @param instance
         * @returns {any}
         */
        public static writeObject( instance:ISerializable ):ISerializable
        {
            var obj:any = <ISerializable>{};
            var register:ISerializableRegister = Serializer.getSerializableRegister( instance );
            register.keys.forEach(( key:string )=>
            {
                var value:any = instance[key];
                if( !value && !Serializer.isNumeric( value )) return; // don't getSerializableProperties void/empty/undefined
                Serializer.writeAny( obj, key, value, register.serializerData );
            });
            return obj;
        }

        /**
         * Rehidrates the instance with the values provided by the passed object
         * @param instance
         * @param obj
         */
        public static readObject( instance:ISerializable, obj:ISerializable ):ISerializable
        {
            var register:ISerializableRegister = Serializer.getSerializableRegister( instance );
            Serializer.getSerializableRegister( instance ).keys
                .forEach( ( key:string )=> Serializer.readAny( obj[key], key, instance, register.serializerData ) );
            return instance;
        }



        // Private Methods
        /**
         *
         * @param array
         * @returns {any[]}
         */
        private static writeArray( array:any[] ):any[]
        {
            var dummyObjectArray:{array:any[]} = { array:[] };
            array.forEach( ( value , i )=> Serializer.writeAny( dummyObjectArray.array, i, value , Serializer.getSerializableRegisterData( value )  ) );
            return dummyObjectArray.array;
        }

        /**
         *
         * @param value
         * @param key
         * @param obj
         * @param SerializerDataClass
         */
        private static writeAny( obj:any,key:any,value:any, SerializerDataClass:any = null , fromArray:boolean = false )
        {

            if( SerializerDataClass && typeof SerializerDataClass.prototype["set_"+key] == "function" )
            {
                obj[key] = SerializerDataClass.prototype["set_"+key]( value );
                return;
            }

            var elementType = typeof value;

            switch( true )
            {
                case elementType=="boolean":
                case elementType=="string":
                case elementType=="number":
                    obj[key] = value;
                    break;
                case Array.isArray( value ):
                    obj[key] = Serializer.writeArray( value );
                    break;
                case elementType=="object" && !Array.isArray( value ):
                    obj[key] = Serializer.isExternalizable( value ) ? Serializer.writeObject( value ):JSON.parse(JSON.stringify( value ));
                    break;
            }

        }

        /**
         * @param array
         * @returns {any[]}
         */
        private static readArray( array:any[] ):any[]
        {
            var resultArray:any[] = [];

            array.forEach( ( element, i )=>{
                Serializer.readAny( element, i, resultArray, Serializer.getSerializableRegisterData( element ) );
            });
            return resultArray;
        }

        /**
         ** @param element
         * @param key
         * @param target
         * @param SerializerDataClass
         */
        private static readAny( element:any, key:any, target:any, SerializerDataClass:any )
        {

            if( SerializerDataClass && typeof SerializerDataClass.prototype["get_"+key] == "function" )
            {
                target[key] = SerializerDataClass.prototype["get_"+key]( element );
                return;
            }

            var type:string = typeof element;
            switch( true )
            {
                case type=="boolean":
                case type=="string":
                case type=="number":
                    target[key] = element;
                    break;
                case Array.isArray( element ):
                    target[key] = Serializer.readArray( element );
                    break;
                case type=="object" && !Array.isArray( element ):
                    if( element.hasOwnProperty('@serializable') )
                    {
                        var moduleParts:string[] = element['@serializable'].split('.');
                        var classPath:string = moduleParts.join('.');
                        if( !target[key] ) target[key] = Serializer.getClass(classPath);
                        target[key].readObject( element );
                     }
                    else
                    {
                        target[key] = element;
                    }
                    break;
            }

        }

        /* Helper Methods */

        /**

         ** @param SerializerDataClass
         * @returns {string[]}
         */
        private static getMixedNames( SerializerDataClass:any ):string[]
        {
            return Object.getOwnPropertyNames( new SerializerDataClass() ).concat("@serializable");
        }


        /**

         ** @param instance
         * @returns {boolean}
         */
        private static isExternalizable( instance ):boolean
        {
            return '@serializable' in instance && typeof instance.writeObject == "function" && typeof instance.readObject == "function";
        }

        /**

         ** @param name
         * @param context
         * @returns {any}
         */
        private static getClassFromPath( name:string , context:any = window ):any
        {
            name.split('.').forEach( ctx=>context = context[ ctx ] );
            return context;
        }

        /**

         ** @param name
         * @param context
         * @returns {any}
         */
        private static getClass( name:string , context:any = window ):any
        {
            name.split('.').forEach( ctx=>context = context[ ctx ] );
            return new context;
        }

        /**

                  ** @param instance
         * @returns {ISerializableRegister}
         */
        private static getSerializableRegister( instance:ISerializable ):ISerializableRegister
        {
            var props:ISerializableRegister = Serializer.serializableRegisters[ instance['@serializable'] ] || null;
            return props;
        }

        /**
         *
         * @param instance
         * @returns {ISerializableRegister}
         */
        private static getSerializableRegisterData( instance:ISerializable ):typeof SerializerHelper
        {

            var register = Serializer.getSerializableRegister( instance );
            return register ? register.serializerData:null;
        }

        private static isNumeric(n:any):boolean
        {
            return !isNaN(parseFloat(n)) && isFinite(n);
        }
    }
}

/* DEMO CODE */


import ISerializable = io.xperiments.utils.serialize.ISerializable;
import Serializable = io.xperiments.utils.serialize.Serializable;

import ISerializerHelper = io.xperiments.utils.serialize.ISerializerHelper;
import Serializer = io.xperiments.utils.serialize.Serializer;

class User extends Serializable
{
    name:string;
    surname:string;
    street:string;
    number:number;
    date:Date;
}

class UserSerializer implements ISerializerHelper
{
    "@serializer":string = null;
    date:Date = null;
    name:string  = null;
    surname:string  = null;
    street:string  = null;
    number:number  = null;
    set_date(date:Date):string
    {
        return [ date.getFullYear(), date.getMonth()+1, date.getDate()].join('/');
    }
    get_date(dateString:string):Date
    {
        var dateParts:string[] = dateString.split('/');
        var date = new Date();
        date.setFullYear( parseInt(dateParts[0],10));
        date.setMonth( parseInt(dateParts[1],10)-1);
        date.setDate( parseInt(dateParts[2],10));
        return date;
    }
}

// Registration
Serializer.registerClass(()=>{ return User },UserSerializer);


// Creane new user instance and populate it with some values
var sourceInstance:User = new User();
    sourceInstance.name = "John";
    sourceInstance.surname = "Smith";
    sourceInstance.street = "Some Street Address";
    sourceInstance.number = 67;
    sourceInstance.date = new Date();

// Serialize it and store it somewhere    
var serializedObject:ISerializable = sourceInstance.writeObject();

// later to recompose it from data saved to disk
var cloneUserInstance:User = new User();
cloneUserInstance.readObject( serializedObject );

console.log( sourceInstance, cloneUserInstance )</pre></div>

        </section>
    </article>

</main>


    <footer class="site-footer">
        <div class="inner">
            <section class="copyright">&copy; <a href="http://www.xperiments.io/">xperiments.io</a> 2014</section>
        </div>
    </footer>
    </div>
    <script src="/scripts/prism.js" data-manual></script>
    <script src="/scripts/app.js"></script>
	<script>
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
				m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

		ga('create', 'UA-4009710-5', 'xperiments.io');
		ga('send', 'pageview');

	</script>
  </body>
</html>

